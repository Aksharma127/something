<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project: Procedural Sunset</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
</head>
<body>

    <header class="hero">
        <div class="hero-content">
            <h1>Procedural Sunset</h1>
            <p class="subtitle">Generating atmospheric landscapes with Python & Perlin Noise</p>
        </div>
    </header>

    <main class="container">

        <section class="section">
            <h2>The Vision vs. The Result</h2>
            <p>The goal was to programmatically recreate a beautiful, stylized sunset. Below is the original inspiration alongside the final image generated entirely by the Python script.</p>
            <div class="comparison-grid">
                <div class="image-card">
                    <h3>Inspiration</h3>
                    <img src="inspiration.png" alt="Inspiration image of a stylized sunset">
                </div>
                <div class="image-card">
                    <h3>Generated Result</h3>
                    <img src="result.png" alt="Procedurally generated sunset image">
                </div>
            </div>
        </section>

        <section class="section">
            <h2>How It Works: The Artistic Algorithm</h2>
            <p>The image is built in layers, from back to front, using a combination of mathematical gradients and controlled randomness.</p>
            <div class="process-grid">
                <div class="process-card">
                    <div class="process-icon">1</div>
                    <h3>The Sky Gradient</h3>
                    <p>A multi-stop vertical gradient is created, smoothly blending from a deep purple at the top, through a vibrant pink, to a warm orange at the horizon.</p>
                </div>
                <div class="process-card">
                    <div class="process-icon">2</div>
                    <h3>The Starfield</h3>
                    <p>Before anything else, hundreds of stars are sprinkled onto the upper portion of the sky canvas, each with a random position and brightness.</p>
                </div>
                <div class="process-card">
                    <div class="process-icon">3</div>
                    <h3>Fractal Mountains</h3>
                    <p>The core of the landscape. Each mountain range is a line generated by Perlin Noise, a type of algorithm that creates organic, natural-looking randomness. By layering multiple noise functions (octaves), we get detailed, jagged peaks.</p>
                </div>
                <div class="process-card">
                    <div class="process-icon">4</div>
                    <h3>Atmospheric Depth</h3>
                    <p>Multiple mountain layers are drawn on top of each other. The layers in the back are given a lighter, more desaturated color, while the foreground layers are darker. This simple trick simulates atmospheric perspective and creates a sense of immense depth.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>The Code Behind the Peaks</h2>
            <p>This Python function uses the `noise` library to generate the silhouette for a single mountain layer. The key is tuning parameters like `octaves` and `persistence` to get the desired jaggedness.</p>
            <div class="code-block">
                <pre><code><span class="comment"># Simplified function to generate a mountain silhouette</span>
<span class="keyword">def</span> <span class="function">add_mountain_layer</span>(<span class="params">canvas, color, base_height, ...</span>):
    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="function">range</span>(width):
        <span class="comment"># Generate a noise value for each column</span>
        n = noise.pnoise1(
            x * noise_scale,
            octaves=<span class="number">8</span>,
            persistence=<span class="number">0.5</span>,
            lacunarity=<span class="number">2.0</span>
        )
        
        <span class="comment"># Convert noise value to a pixel height</span>
        mountain_height = base_height + n * amplitude
        
        <span class="comment"># Fill all pixels below with a solid color</span>
        canvas[mountain_height:, x] = color
    <span class="keyword">return</span> canvas</code></pre>
            </div>
        </section>

    </main>

    <footer>
        <p>A project by Aksharma127. India, 2025.</p>
        <a href="https://github.com/Aksharma127/something" class="button" target="_blank">View on GitHub</a>
    </footer>

</body>
</html>
